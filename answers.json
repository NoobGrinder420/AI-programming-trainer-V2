{"0": "class Solution(object):\n  def twoSum(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    d = {}\n    for i, num in enumerate(nums):\n      if target - num in d:\n        return [d[target - num], i]\n      d[num] = i\n    # no special case handling because it's assumed that it has only one solution\n", "1": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  # maybe standard version\n  def _addTwoNumbers(self, l1, l2):\n    \"\"\"\n    :type l1: ListNode\n    :type l2: ListNode\n    :rtype: ListNode\n    \"\"\"\n    p = dummy = ListNode(-1)\n    carry = 0\n    while l1 and l2:\n      p.next = ListNode(l1.val + l2.val + carry)\n      carry = p.next.val // 10\n      p.next.val %= 10\n      p = p.next\n      l1 = l1.next\n      l2 = l2.next\n\n    res = l1 or l2\n    while res:\n      p.next = ListNode(res.val + carry)\n      carry = p.next.val // 10\n      p.next.val %= 10\n      p = p.next\n      res = res.next\n    if carry:\n      p.next = ListNode(1)\n    return dummy.next\n\n  # shorter version\n  def addTwoNumbers(self, l1, l2):\n    p = dummy = ListNode(-1)\n    carry = 0\n    while l1 or l2 or carry:\n      val = (l1 and l1.val or 0) + (l2 and l2.val or 0) + carry\n      carry = val // 10\n      p.next = ListNode(val % 10)\n      l1 = l1 and l1.next\n      l2 = l2 and l2.next\n      p = p.next\n    return dummy.next\n", "2": "class Solution(object):\n  def _lengthOfLongestSubstring(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    d = collections.defaultdict(int)\n    l = ans = 0\n    for i, c in enumerate(s):\n      while l > 0 and d[c] > 0:\n        d[s[i - l]] -= 1\n        l -= 1\n      d[c] += 1\n      l += 1\n      ans = max(ans, l)\n    return ans\n\n  def lengthOfLongestSubstring(self, s):\n    d = {}\n    start = 0\n    ans = 0\n    for i, c in enumerate(s):\n      if c in d:\n        start = max(start, d[c] + 1)\n      d[c] = i\n      ans = max(ans, i - start + 1)\n    return ans\n", "3": "class Solution(object):\n  def findMedianSortedArrays(self, nums1, nums2):\n    a, b = sorted((nums1, nums2), key=len)\n    m, n = len(a), len(b)\n    after = (m + n - 1) / 2\n    lo, hi = 0, m\n    while lo < hi:\n      i = (lo + hi) / 2\n      if after - i - 1 < 0 or a[i] >= b[after - i - 1]:\n        hi = i\n      else:\n        lo = i + 1\n    i = lo\n    nextfew = sorted(a[i:i + 2] + b[after - i:after - i + 2])\n    return (nextfew[0] + nextfew[1 - (m + n) % 2]) / 2.0\n", "4": "class Solution(object):\n  def longestPalindrome(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    left = right = 0\n    n = len(s)\n    for i in range(n - 1):\n      if 2 * (n - i) + 1 < right - left + 1:\n        break\n      l = r = i\n      while l >= 0 and r < n and s[l] == s[r]:\n        l -= 1\n        r += 1\n      if r - l - 2 > right - left:\n        left = l + 1\n        right = r - 1\n      l = i\n      r = i + 1\n      while l >= 0 and r < n and s[l] == s[r]:\n        l -= 1\n        r += 1\n      if r - l - 2 > right - left:\n        left = l + 1\n        right = r - 1\n    return s[left:right + 1]\n", "5": "class Solution(object):\n  def convert(self, s, numRows):\n    \"\"\"\n    :type s: str\n    :type numRows: int\n    :rtype: str\n    \"\"\"\n    if numRows <= 1:\n      return s\n    n = len(s)\n    ans = []\n    step = 2 * numRows - 2\n    for i in range(numRows):\n      one = i\n      two = -i\n      while one < n or two < n:\n        if 0 <= two < n and one != two and i != numRows - 1:\n          ans.append(s[two])\n        if one < n:\n          ans.append(s[one])\n        one += step\n        two += step\n    return \"\".join(ans)\n", "6": "class Solution(object):\n  def reverse(self, x):\n    \"\"\"\n    :type x: int\n    :rtype: int\n    \"\"\"\n    sign = x < 0 and -1 or 1\n    x = abs(x)\n    ans = 0\n    while x:\n      ans = ans * 10 + x % 10\n      x /= 10\n    return sign * ans if ans <= 0x7fffffff else 0\n", "7": "class Solution(object):\n  def myAtoi(self, s):\n    \"\"\"\n    :type str: str\n    :rtype: int\n    \"\"\"\n    s = s.strip()\n    sign = 1\n    if not s:\n      return 0\n    if s[0] in [\"+\", \"-\"]:\n      if s[0] == \"-\":\n        sign = -1\n      s = s[1:]\n    ans = 0\n    for c in s:\n      if c.isdigit():\n        ans = ans * 10 + int(c)\n      else:\n        break\n    ans *= sign\n    if ans > 2147483647:\n      return 2147483647\n    if ans < -2147483648:\n      return -2147483648\n    return ans\n", "8": "class Solution(object):\n  # normal way\n  def _isPalindrome(self, x):\n    \"\"\"\n    :type x: int\n    :rtype: bool\n    \"\"\"\n    z = x\n    y = 0\n    while x > 0:\n      y = y * 10 + x % 10\n      x /= 10\n    return z == y\n\n  # faster way\n  def isPalindrome(self, x):\n    \"\"\"\n    :type x: int\n    :rtype: bool\n    \"\"\"\n    if x < 0 or (x != 0 and x % 10 == 0):\n      return False\n    half = 0\n    while x > half:\n      half = half * 10 + x % 10\n      x /= 10\n    return x == half or half / 10 == x\n", "9": "class Solution(object):\n  def isMatch(self, s, p):\n    \"\"\"\n    :type s: str\n    :type p: str\n    :rtype: bool\n    \"\"\"\n    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n    dp[0][0] = True\n    for j in range(1, len(p) + 1):\n      if p[j - 1] == \"*\":\n        dp[0][j] = dp[0][j - 2]\n\n    for i in range(1, len(s) + 1):\n      for j in range(1, len(p) + 1):\n        if p[j - 1] != \"*\":\n          dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == \".\")\n        else:\n          dp[i][j] = dp[i][j - 2] or dp[i - 1][j] and (p[j - 2] == s[i - 1] or p[j - 2] == \".\")\n    return dp[-1][-1]\n", "10": "class Solution(object):\n  def maxArea(self, height):\n    \"\"\"\n    :type height: List[int]\n    :rtype: int\n    \"\"\"\n    ans = left = 0\n    right = len(height) - 1\n    while left < right:\n      ans = max(ans, (right - left) * min(height[left], height[right]))\n      if height[left] <= height[right]:\n        left += 1\n      else:\n        right -= 1\n    return ans\n", "11": "class Solution(object):\n  def intToRoman(self, num):\n    \"\"\"\n    :type num: int\n    :rtype: str\n    \"\"\"\n    ans = \"\"\n    values = {\"M\": 1000, \"D\": 500, \"C\": 100, \"L\": 50, \"X\": 10, \"V\": 5, \"I\": 1}\n    literals = [\"M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\"]\n    for idx in [0, 2, 4]:\n      k = num / values[literals[idx]]\n      re = (num % values[literals[idx]]) / values[literals[idx + 2]]\n      ans += k * literals[idx]\n      if re >= 9:\n        ans += literals[idx + 2] + literals[idx]\n      elif re >= 5:\n        ans += literals[idx + 1] + (re - 5) * literals[idx + 2]\n      elif re == 4:\n        ans += literals[idx + 2] + literals[idx + 1]\n      else:\n        ans += re * literals[idx + 2]\n      num %= values[literals[idx + 2]]\n    return ans\n", "12": "class Solution(object):\n  def romanToInt(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    d = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    ans = 0\n    for i in range(0, len(s) - 1):\n      c = s[i]\n      cafter = s[i + 1]\n      if d[c] < d[cafter]:\n        ans -= d[c]\n      else:\n        ans += d[c]\n    ans += d[s[-1]]\n    return ans\n", "13": "class Solution(object):\n  def longestCommonPrefix(self, strs):\n    \"\"\"\n    :type strs: List[str]\n    :rtype: str\n    \"\"\"\n    if len(strs) == 0:\n      return \"\"\n    i = 0\n    j = 0\n    end = 0\n    while j < len(strs) and i < len(strs[j]):\n      if j == 0:\n        char = strs[j][i]\n      else:\n        if strs[j][i] != char:\n          break\n\n      if j == len(strs) - 1:\n        i += 1\n        j = 0\n        end += 1\n      else:\n        j += 1\n\n    return strs[j][:end]\n", "14": "class Solution(object):\n  def threeSum(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    nums.sort()\n    for i in range(0, len(nums)):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      target = 0 - nums[i]\n      start, end = i + 1, len(nums) - 1\n      while start < end:\n        if nums[start] + nums[end] > target:\n          end -= 1\n        elif nums[start] + nums[end] < target:\n          start += 1\n        else:\n          res.append((nums[i], nums[start], nums[end]))\n          end -= 1\n          start += 1\n          while start < end and nums[end] == nums[end + 1]:\n            end -= 1\n          while start < end and nums[start] == nums[start - 1]:\n            start += 1\n    return res\n", "15": "class Solution(object):\n  def threeSumClosest(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    nums.sort()\n    ans = 0\n    diff = float(\"inf\")\n    for i in range(0, len(nums)):\n      start, end = i + 1, len(nums) - 1\n      while start < end:\n        sum = nums[i] + nums[start] + nums[end]\n        if sum > target:\n          if abs(target - sum) < diff:\n            diff = abs(target - sum)\n            ans = sum\n          end -= 1\n        else:\n          if abs(target - sum) < diff:\n            diff = abs(target - sum)\n            ans = sum\n          start += 1\n    return ans\n", "16": "class Solution(object):\n  def letterCombinations(self, digits):\n    \"\"\"\n    :type digits: str\n    :rtype: List[str]\n    \"\"\"\n    if len(digits) == 0:\n      return []\n\n    d = {1: \"\", 2: \"abc\", 3: \"def\", 4: \"ghi\", 5: \"jkl\", 6: \"mno\", 7: \"pqrs\", 8: \"tuv\", 9: \"wxyz\"}\n\n    def dfs(digits, index, path, res, d):\n      if index == len(digits):\n        res.append(\"\".join(path))\n        return\n\n      digit = int(digits[index])\n      for c in d.get(digit, []):\n        path.append(c)\n        dfs(digits, index + 1, path, res, d)\n        path.pop()\n\n    res = []\n    dfs(digits, 0, [], res, d)\n    return res\n", "17": "class Solution(object):\n  def fourSum(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[List[int]]\n    \"\"\"\n    nums.sort()\n    res = []\n    for i in range(0, len(nums)):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      for j in range(i + 1, len(nums)):\n        if j > i + 1 and nums[j] == nums[j - 1]:\n          continue\n        start = j + 1\n        end = len(nums) - 1\n        while start < end:\n          sum = nums[i] + nums[j] + nums[start] + nums[end]\n          if sum < target:\n            start += 1\n          elif sum > target:\n            end -= 1\n          else:\n            res.append((nums[i], nums[j], nums[start], nums[end]))\n            start += 1\n            end -= 1\n            while start < end and nums[start] == nums[start - 1]:\n              start += 1\n            while start < end and nums[end] == nums[end + 1]:\n              end -= 1\n    return res\n", "18": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def removeNthFromEnd(self, head, n):\n    \"\"\"\n    :type head: ListNode\n    :type n: int\n    :rtype: ListNode\n    \"\"\"\n    dummy = ListNode(-1)\n    dummy.next = head\n    fast = slow = dummy\n\n    while n and fast:\n      fast = fast.next\n      n -= 1\n\n    while fast.next and slow.next:\n      fast = fast.next\n      slow = slow.next\n\n    slow.next = slow.next.next\n    return dummy.next\n", "19": "class Solution(object):\n  def isValid(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    stack = []\n    d = [\"()\", \"[]\", \"{}\"]\n    for i in range(0, len(s)):\n      stack.append(s[i])\n      if len(stack) >= 2 and stack[-2] + stack[-1] in d:\n        stack.pop()\n        stack.pop()\n    return len(stack) == 0\n", "20": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def mergeTwoLists(self, l1, l2):\n    \"\"\"\n    :type l1: ListNode\n    :type l2: ListNode\n    :rtype: ListNode\n    \"\"\"\n    head = dummy = ListNode(-1)\n    while l1 and l2:\n      if l1.val < l2.val:\n        head.next = l1\n        l1 = l1.next\n      else:\n        head.next = l2\n        l2 = l2.next\n      head = head.next\n    if l1:\n      head.next = l1\n    if l2:\n      head.next = l2\n    return dummy.next\n", "21": "class Solution(object):\n  def generateParenthesis(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: List[str]\n    \"\"\"\n\n    def dfs(left, path, res, n):\n      if len(path) == 2 * n:\n        if left == 0:\n          res.append(\"\".join(path))\n        return\n\n      if left < n:\n        path.append(\"(\")\n        dfs(left + 1, path, res, n)\n        path.pop()\n      if left > 0:\n        path.append(\")\")\n        dfs(left - 1, path, res, n)\n        path.pop()\n\n    res = []\n    dfs(0, [], res, n)\n    return res\n", "22": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\nimport heapq\n\n# overwrite the comparison function, so the node can be comparable\nListNode.__lt__ = lambda x, y: (x.val < y.val)\n\nclass Solution(object):\n  def mergeKLists(self, lists):\n    \"\"\"\n    :type lists: List[ListNode]\n    :rtype: ListNode\n    \"\"\"\n    heap = []\n    p = dummy = ListNode(-1)\n    for i in range(0, len(lists)):\n      node = lists[i]\n      if not node:\n        continue\n      heapq.heappush(heap, node)\n\n    while heap:\n      value, node = heapq.heappop(heap)\n      p.next = node\n      p = p.next\n      if node.next:\n        node = node.next\n        heapq.heappush(heap, node)\n    return dummy.next\n", "23": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def swapPairs(self, head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n\n    def reverseList(head, k):\n      pre = None\n      cur = head\n      while cur and k > 0:\n        tmp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = tmp\n        k -= 1\n      head.next = cur\n      return cur, pre\n\n    if not head or not head.next:\n      return head\n    ret = head.next\n    p = head\n    pre = None\n    while p:\n      next, newHead = reverseList(p, 2)\n      if pre:\n        pre.next = newHead\n      pre = p\n      p = next\n    return ret\n", "24": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def reverseKGroup(self, head, k):\n    \"\"\"\n    :type head: ListNode\n    :type k: int\n    :rtype: ListNode\n    \"\"\"\n\n    def reverseList(head, k):\n      pre = None\n      cur = head\n      while cur and k > 0:\n        tmp = cur.next\n        cur.next = pre\n        pre = cur\n        cur = tmp\n        k -= 1\n      head.next = cur\n      return cur, pre\n\n    length = 0\n    p = head\n    while p:\n      length += 1\n      p = p.next\n    if length < k:\n      return head\n    step = length / k\n    ret = None\n    pre = None\n    p = head\n    while p and step:\n      next, newHead = reverseList(p, k)\n      if ret is None:\n        ret = newHead\n      if pre:\n        pre.next = newHead\n      pre = p\n      p = next\n      step -= 1\n    return ret\n", "25": "class Solution(object):\n  def removeDuplicates(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 1:\n      return len(nums)\n    slow = 0\n    for i in range(1, len(nums)):\n      if nums[i] != nums[slow]:\n        slow += 1\n        nums[slow] = nums[i]\n    return slow + 1\n", "26": "class Solution(object):\n  def removeElement(self, nums, val):\n    \"\"\"\n    :type nums: List[int]\n    :type val: int\n    :rtype: int\n    \"\"\"\n    slow = -1\n    for i in range(0, len(nums)):\n      if nums[i] != val:\n        slow += 1\n        nums[slow] = nums[i]\n    return slow + 1\n", "27": "class Solution(object):\n  def strStr(self, haystack, needle):\n    \"\"\"\n    :type haystack: str\n    :type needle: str\n    :rtype: int\n    \"\"\"\n    if len(haystack) == len(needle):\n      if haystack == needle:\n        return 0\n      else:\n        return -1\n\n    for i in range(0, len(haystack)):\n      k = i\n      j = 0\n      while j < len(needle) and k < len(haystack) and haystack[k] == needle[j]:\n        j += 1\n        k += 1\n      if j == len(needle):\n        return i\n    return -1 if needle else 0\n", "28": "class Solution(object):\n  def divide(self, dividend, divisor):\n    \"\"\"\n    :type dividend: int\n    :type divisor: int\n    :rtype: int\n    \"\"\"\n    if divisor == 0:\n      return 0x7fffffff\n    sign = 1\n    if dividend * divisor < 0:\n      sign = -1\n    ans = 0\n    cnt = 1\n    dividend = abs(dividend)\n    divisor = abs(divisor)\n    subsum = divisor\n    while dividend >= divisor:\n      while (subsum << 1) <= dividend:\n        cnt <<= 1\n        subsum <<= 1\n      ans += cnt\n      cnt = 1\n      dividend -= subsum\n      subsum = divisor\n    return max(min(sign * ans, 0x7fffffff), -2147483648)\n", "29": "from collections import deque\n\n\nclass Solution(object):\n  def findSubstring(self, s, words):\n    \"\"\"\n    :type s: str\n    :type words: List[str]\n    :rtype: List[int]\n    \"\"\"\n    if len(words) > len(s):\n      return []\n    d = {}\n    t = {}\n    ans = []\n    deq = deque([])\n    wl = len(words[0])\n    fullscore = 0\n    for word in words:\n      d[word] = d.get(word, 0) + 1\n      fullscore += 1\n\n    for i in range(0, len(s)):\n      head = start = i\n      t.clear()\n      score = 0\n\n      while start + wl <= len(s) and s[start:start + wl] in d:\n        cword = s[start:start + wl]\n        t[cword] = t.get(cword, 0) + 1\n        if t[cword] <= d[cword]:\n          score += 1\n        else:\n          break\n        start += wl\n\n      if score == fullscore:\n        ans.append(head)\n\n    return ans\n", "30": "class Solution(object):\n  def nextPermutation(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if nums is None or len(nums) <= 1:\n      return\n\n    pos = None\n    p = len(nums) - 2\n    # find the first number that is not in correct order\n    while p >= 0:\n      if nums[p + 1] > nums[p]:\n        pos = p\n        break\n      p -= 1\n\n    if pos is None:\n      self.reverse(nums, 0, len(nums) - 1)\n      return\n\n    # find the min value in the rest of the array\n    minPos, minV = pos + 1, nums[pos + 1]\n    for i in range(pos + 1, len(nums)):\n      if nums[i] <= minV and nums[i] > nums[pos]:\n        minV = nums[i]\n        minPos = i\n    # swap the two above number and reverse the array from `pos`\n    nums[pos], nums[minPos] = nums[minPos], nums[pos]\n    self.reverse(nums, pos + 1, len(nums) - 1)\n\n  def reverse(self, nums, start, end):\n    while start < end:\n      nums[start], nums[end] = nums[end], nums[start]\n      start += 1\n      end -= 1\n", "31": "class Solution(object):\n  def longestValidParentheses(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    dp = [0 for _ in range(0, len(s))]\n    left = 0\n    ans = 0\n    for i in range(0, len(s)):\n      if s[i] == \"(\":\n        left += 1\n      elif left > 0:\n        left -= 1\n        dp[i] = dp[i - 1] + 2\n        j = i - dp[i]\n        if j >= 0:\n          dp[i] += dp[j]\n        ans = max(ans, dp[i])\n    return ans\n", "32": "class Solution(object):\n  def search(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n      return -1\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n      mid = (right + left) / 2\n      if nums[mid] == target:\n        return mid\n      if nums[mid] >= nums[left]:\n        if nums[left] <= target <= nums[mid]:\n          right = mid - 1\n        else:\n          left = mid + 1\n      else:\n        if nums[mid] <= target <= nums[right]:\n          left = mid + 1\n        else:\n          right = mid - 1\n    return -1\n", "33": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        def findRange(left):\n            l, r = 0, len(nums) - 1\n            m = 0\n            while l <= r:\n                m = l + (r - l) // 2\n                if nums[m] < target:\n                    l = m + 1\n                elif nums[m] > target:\n                    r = m - 1\n                elif left and m > 0 and nums[m - 1] == nums[m]:\n                    r = m - 1\n                elif not left and m + 1 < len(nums) and nums[m + 1] == nums[m]:\n                    l = m + 1\n                else:\n                    return m\n            if m < len(nums) and nums[m] == target:\n                return m\n            else:\n                return -1\n        return [findRange(True), findRange(False)]\n", "34": "class Solution(object):\n  def searchInsert(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    lo = 0\n    hi = len(nums)\n    while lo < hi:\n      mid = lo + (hi - lo) / 2\n      if nums[mid] > target:\n        hi = mid\n      elif nums[mid] < target:\n        lo = mid + 1\n      else:\n        return mid\n    return lo\n", "35": "class Solution(object):\n  def isValidSudoku(self, board):\n    \"\"\"\n    :type board: List[List[str]]\n    :rtype: bool\n    \"\"\"\n    cacheCol = [[0] * 9 for _ in range(0, 10)]\n    cacheRow = [[0] * 9 for _ in range(0, 10)]\n    cacheBox = [[0] * 9 for _ in range(0, 10)]\n\n    for i in range(0, 9):\n      for j in range(0, 9):\n        ib = (i / 3) * 3 + j / 3\n        if board[i][j] == \".\":\n          continue\n        num = int(board[i][j]) - 1\n        if cacheRow[i][num] != 0 or cacheCol[j][num] != 0 or cacheBox[ib][num] != 0:\n          return False\n        cacheRow[i][num] = 1\n        cacheCol[j][num] = 1\n        cacheBox[ib][num] = 1\n    return True\n", "36": "class Solution(object):\n  def solveSudoku(self, board):\n    \"\"\"\n    :type board: List[List[str]]\n    :rtype: void Do not return anything, modify board in-place instead.\n    \"\"\"\n    cacheBox = [[0] * len(board) for _ in range(len(board))]\n    cacheRow = [[0] * len(board) for _ in range(len(board))]\n    cacheCol = [[0] * len(board) for _ in range(len(board))]\n\n    def helper(board, i, j, cacheRow, cacheCol, cacheBox):\n      if board[i][j] == \".\":\n        for k in range(1, 10):\n          if i < 0 or i >= len(board) or j < 0 or j >= len(board):\n            continue\n          ib = (i / 3) * 3 + j / 3\n          if cacheRow[i][k - 1] == 1 or cacheCol[j][k - 1] == 1 or cacheBox[ib][k - 1] == 1:\n            continue\n\n          cacheRow[i][k - 1] = cacheCol[j][k - 1] = cacheBox[ib][k - 1] = 1\n          board[i][j] = str(k)\n          if i == j == len(board) - 1:\n            return True\n          if i + 1 < len(board):\n            if helper(board, i + 1, j, cacheRow, cacheCol, cacheBox):\n              return True\n          elif j + 1 < len(board):\n            if helper(board, 0, j + 1, cacheRow, cacheCol, cacheBox):\n              return True\n          board[i][j] = \".\"\n          cacheRow[i][k - 1] = cacheCol[j][k - 1] = cacheBox[ib][k - 1] = 0\n      else:\n        if i == j == len(board) - 1:\n          return True\n        if i + 1 < len(board):\n          if helper(board, i + 1, j, cacheRow, cacheCol, cacheBox):\n            return True\n        elif j + 1 < len(board):\n          if helper(board, 0, j + 1, cacheRow, cacheCol, cacheBox):\n            return True\n      return False\n\n    for i in range(len(board)):\n      for j in range(len(board)):\n        if board[i][j] != \".\":\n          ib = (i / 3) * 3 + j / 3\n          k = int(board[i][j]) - 1\n          cacheRow[i][k] = cacheCol[j][k] = cacheBox[ib][k] = 1\n    print\n    helper(board, 0, 0, cacheRow, cacheCol, cacheBox)\n", "37": "class Solution(object):\n  def countAndSay(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: str\n    \"\"\"\n    ans = \"1\"\n    n -= 1\n    while n > 0:\n      res = \"\"\n      pre = ans[0]\n      count = 1\n      for i in range(1, len(ans)):\n        if pre == ans[i]:\n          count += 1\n        else:\n          res += str(count) + pre\n          pre = ans[i]\n          count = 1\n      res += str(count) + pre\n      ans = res\n      n -= 1\n    return ans\n", "38": "class Solution(object):\n  def combinationSum(self, candidates, target):\n    \"\"\"\n    :type candidates: List[int]\n    :type target: int\n    :rtype: List[List[int]]\n    \"\"\"\n\n    def dfs(candidates, start, target, path, res):\n      if target == 0:\n        return res.append(path + [])\n\n      for i in range(start, len(candidates)):\n        if target - candidates[i] >= 0:\n          path.append(candidates[i])\n          dfs(candidates, i, target - candidates[i], path, res)\n          path.pop()\n\n    res = []\n    dfs(candidates, 0, target, [], res)\n    return res\n", "39": "class Solution(object):\n  def combinationSum2(self, candidates, target):\n    \"\"\"\n    :type candidates: List[int]\n    :type target: int\n    :rtype: List[List[int]]\n    \"\"\"\n\n    def dfs(nums, target, start, visited, path, res):\n      if target == 0:\n        res.append(path + [])\n        return\n\n      for i in range(start, len(nums)):\n        if i > start and nums[i] == nums[i - 1]:\n          continue\n        if target - nums[i] < 0:\n          return 0\n        if i not in visited:\n          visited.add(i)\n          path.append(nums[i])\n          dfs(nums, target - nums[i], i + 1, visited, path, res)\n          path.pop()\n          visited.discard(i)\n\n    candidates.sort()\n    res = []\n    visited = set([])\n    dfs(candidates, target, 0, visited, [], res)\n    return res\n", "40": "class Solution(object):\n  def firstMissingPositive(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    i = 0\n    while i < len(nums):\n      if 0 < nums[i] <= len(nums) and nums[nums[i] - 1] != nums[i]:\n        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n      else:\n        i += 1\n\n    for i in range(0, len(nums)):\n      if nums[i] != i + 1:\n        return i + 1\n    return len(nums) + 1\n", "41": "class Solution(object):\n  def trap(self, height):\n    \"\"\"\n    :type height: List[int]\n    :rtype: int\n    \"\"\"\n    ans = left = 0\n    right = len(height) - 1\n    leftWall = rightWall = float(\"-inf\")\n    while left <= right:\n      if leftWall <= rightWall:\n        ans += max(0, leftWall - height[left])\n        leftWall = max(leftWall, height[left])\n        left += 1\n      else:\n        ans += max(0, rightWall - height[right])\n        rightWall = max(rightWall, height[right])\n        right -= 1\n    return ans\n", "42": "class Solution(object):\n  def multiply(self, num1, num2):\n    \"\"\"\n    :type num1: str\n    :type num2: str\n    :rtype: str\n    \"\"\"\n    ans = [0] * (len(num1) + len(num2))\n    for i, n1 in enumerate(reversed(num1)):\n      for j, n2 in enumerate(reversed(num2)):\n        ans[i + j] += int(n1) * int(n2)\n        ans[i + j + 1] += ans[i + j] / 10\n        ans[i + j] %= 10\n    while len(ans) > 1 and ans[-1] == 0:\n      ans.pop()\n    return \"\".join(map(str, ans[::-1]))\n", "43": "class Solution(object):\n  def isMatch(self, s, p):\n    \"\"\"\n    :type s: str\n    :type p: str\n    :rtype: bool\n    \"\"\"\n    i = j = 0\n    lenS = len(s)\n    lenP = len(p)\n    lastMatchPos = 0\n    lastStarPos = -1\n    while i < len(s):\n      if j < lenP and p[j] in (s[i], \"?\"):\n        i += 1\n        j += 1\n      elif j < lenP and p[j] == \"*\":\n        lastMatchPos = i\n        lastStarPos = j\n        j += 1\n      elif lastStarPos > -1:\n        i = lastMatchPos + 1\n        lastMatchPos += 1\n        j = lastStarPos + 1\n      else:\n        return False\n    while j < lenP and p[j] == \"*\":\n      j += 1\n    return j == lenP\n", "44": "class Solution(object):\n  def jump(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    pos = 0\n    ans = 0\n    bound = len(nums)\n    while pos < len(nums) - 1:\n      dis = nums[pos]\n      farthest = posToFarthest = 0\n      for i in range(pos + 1, min(pos + dis + 1, bound)):\n        canReach = i + nums[i]\n        if i == len(nums) - 1:\n          return ans + 1\n        if canReach > farthest:\n          farthest = canReach\n          posToFarthest = i\n      ans += 1\n      pos = posToFarthest\n    return ans\n", "45": "class Solution(object):\n  def permute(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    visited = set([])\n\n    def dfs(nums, path, res, visited):\n      if len(path) == len(nums):\n        res.append(path + [])\n        return\n\n      for i in range(0, len(nums)):\n        # if i > 0 and nums[i - 1] == nums[i]:\n        #     continue\n        if i not in visited:\n          visited.add(i)\n          path.append(nums[i])\n          dfs(nums, path, res, visited)\n          path.pop()\n          visited.discard(i)\n\n    dfs(nums, [], res, visited)\n    return res\n", "46": "class Solution(object):\n  def permuteUnique(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = []\n    nums.sort()\n\n    def dfs(nums, res, path, visited):\n      if len(path) == len(nums):\n        res.append(path + [])\n        return\n\n      for i in range(len(nums)):\n        if i in visited:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and i - 1 not in visited:\n          continue\n        visited |= {i}\n        path.append(nums[i])\n        dfs(nums, res, path, visited)\n        path.pop()\n        visited -= {i}\n\n    dfs(nums, res, [], set())\n    return res\n", "47": "class Solution(object):\n  def rotate(self, matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    if len(matrix) == 0:\n      return\n    h = len(matrix)\n    w = len(matrix[0])\n    for i in range(0, h):\n      for j in range(0, w / 2):\n        matrix[i][j], matrix[i][w - j - 1] = matrix[i][w - j - 1], matrix[i][j]\n\n    for i in range(0, h):\n      for j in range(0, w - 1 - i):\n        matrix[i][j], matrix[w - 1 - j][h - 1 - i] = matrix[w - 1 - j][h - 1 - i], matrix[i][j]\n", "48": "class Solution(object):\n  def groupAnagrams(self, strs):\n    \"\"\"\n    :type strs: List[str]\n    :rtype: List[List[str]]\n    \"\"\"\n\n    def hash(count):\n      p1, p2 = 2903, 29947\n      ret = 0\n      for c in count:\n        ret = ret * p1 + c\n        p1 *= p2\n      return ret\n\n    d = {}\n\n    for str in strs:\n      count = [0] * 26\n      for c in str:\n        count[ord(c) - ord('a')] += 1\n      key = hash(count)\n      if key not in d:\n        d[key] = [str]\n      else:\n        d[key].append(str)\n    return [d[k] for k in d]\n", "49": "class Solution(object):\n  def groupAnagrams(self, strs):\n    \"\"\"\n    :type strs: List[str]\n    :rtype: List[List[str]]\n    \"\"\"\n\n    def hash(count):\n      p1, p2 = 2903, 29947\n      ret = 0\n      for c in count:\n        ret = ret * p1 + c\n        p1 *= p2\n      return ret\n\n    d = {}\n\n    for str in strs:\n      count = [0] * 26\n      for c in str:\n        count[ord(c) - ord('a')] += 1\n      key = hash(count)\n      if key not in d:\n        d[key] = [str]\n      else:\n        d[key].append(str)\n    return [d[k] for k in d]\n", "50": "class Solution(object):\n  def myPow(self, x, n):\n    \"\"\"\n    :type x: float\n    :type n: int\n    :rtype: float\n    \"\"\"\n    if n < 0:\n      n = -n\n      x = 1 / x\n    ans = 1\n    while n:\n      if n & 1:\n        ans *= x\n      x *= x\n      n >>= 1\n    return ans\n", "51": "class Solution(object):\n  def solveNQueens(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: List[List[str]]\n    \"\"\"\n    ans = []\n\n    def dfs(path, n, ans):\n      if len(path) == n:\n        ans.append(drawChess(path))\n        return\n\n      for i in range(n):\n        if i not in path and isValidQueen(path, i):\n          path.append(i)\n          dfs(path, n, ans)\n          path.pop()\n\n    def isValidQueen(path, k):\n      for i in range(len(path)):\n        if abs(k - path[i]) == abs(len(path) - i):\n          return False\n      return True\n\n    def drawChess(path):\n      ret = []\n      chess = [[\".\"] * len(path) for _ in range(len(path))]\n      for i in range(0, len(path)):\n        chess[i][path[i]] = \"Q\"\n      for chs in chess:\n        ret.append(\"\".join(chs))\n      return ret\n\n    dfs([], n, ans)\n    return ans\n", "52": "class Solution(object):\n  def totalNQueens(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n\n    def dfs(path, n):\n      if len(path) == n:\n        return 1\n      res = 0\n      for i in range(n):\n        if i not in path and isValidQueen(path, i):\n          path.append(i)\n          res += dfs(path, n)\n          path.pop()\n      return res\n\n    def isValidQueen(path, k):\n      for i in range(len(path)):\n        if abs(k - path[i]) == abs(len(path) - i):\n          return False\n      return True\n\n    return dfs([], n)\n", "53": "class Solution(object):\n  def maxSubArray(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) == 0:\n      return 0\n    preSum = maxSum = nums[0]\n    for i in range(1, len(nums)):\n      preSum = max(preSum + nums[i], nums[i])\n      maxSum = max(maxSum, preSum)\n    return maxSum\n", "54": "class Solution(object):\n  def spiralOrder(self, matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: List[int]\n    \"\"\"\n    if len(matrix) == 0 or len(matrix[0]) == 0:\n      return []\n    ans = []\n    left, up, down, right = 0, 0, len(matrix) - 1, len(matrix[0]) - 1\n    while left <= right and up <= down:\n      for i in range(left, right + 1):\n        ans += matrix[up][i],\n      up += 1\n      for i in range(up, down + 1):\n        ans += matrix[i][right],\n      right -= 1\n      for i in reversed(range(left, right + 1)):\n        ans += matrix[down][i],\n      down -= 1\n      for i in reversed(range(up, down + 1)):\n        ans += matrix[i][left],\n      left += 1\n    return ans[:(len(matrix) * len(matrix[0]))]\n", "55": "class Solution(object):\n  def canJump(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    pos = 0\n    bound = len(nums)\n    while pos < len(nums) - 1:\n      dis = nums[pos]\n      if dis == 0:\n        return False\n      farthest = posToFarthest = 0\n      for i in range(pos + 1, min(pos + dis + 1, bound)):\n        canReach = i + nums[i]\n        if i == len(nums) - 1:\n          return True\n        if canReach > farthest:\n          farthest = canReach\n          posToFarthest = i\n      pos = posToFarthest\n    return True if pos >= len(nums) - 1 else False\n", "56": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n  def merge(self, intervals):\n    \"\"\"\n    :type intervals: List[Interval]\n    :rtype: List[Interval]\n    \"\"\"\n    ans = []\n    for intv in sorted(intervals, key=lambda x: x.start):\n      if ans and ans[-1].end >= intv.start:\n        ans[-1].end = max(ans[-1].end, intv.end)\n      else:\n        ans.append(intv)\n    return ans\n", "57": "# Definition for an interval.\n# class Interval(object):\n#     def __init__(self, s=0, e=0):\n#         self.start = s\n#         self.end = e\n\nclass Solution(object):\n  def insert(self, intervals, newInterval):\n    \"\"\"\n    :type intervals: List[Interval]\n    :type newInterval: Interval\n    :rtype: List[Interval]\n    \"\"\"\n    s, e = newInterval.start, newInterval.end\n    left = filter(lambda x: x.end < newInterval.start, intervals)\n    right = filter(lambda x: x.start > newInterval.end, intervals)\n    if left + right != intervals:\n      s = min(intervals[len(left)].start, s)\n      e = max(intervals[~len(right)].end, e)\n    return left + [Interval(s, e)] + right\n", "58": "class Solution(object):\n  def lengthOfLastWord(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 0:\n      return 0\n    s = s.split()\n    if len(s) > 0:\n      return len(s[-1])\n    return 0\n", "59": "class Solution(object):\n  def generateMatrix(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: List[List[int]]\n    \"\"\"\n    ans = [[0] * n for _ in range(n)]\n    left, right, up, down = 0, n - 1, 0, n - 1\n    k = 1\n    while left <= right and up <= down:\n      for i in range(left, right + 1):\n        ans[up][i] = k\n        k += 1\n      up += 1\n      for i in range(up, down + 1):\n        ans[i][right] = k\n        k += 1\n      right -= 1\n      for i in reversed(range(left, right + 1)):\n        ans[down][i] = k\n        k += 1\n      down -= 1\n      for i in reversed(range(up, down + 1)):\n        ans[i][left] = k\n        k += 1\n      left += 1\n    return ans\n", "60": "class Solution(object):\n  def getPermutation(self, n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: str\n    \"\"\"\n    visited = [0 for i in range(n)]\n    fact = [math.factorial(n - i - 1) for i in range(n)]\n    ans = \"\"\n    k -= 1\n    for i in range(n):\n      t = k / fact[i]\n      for j in range(n):\n        if not visited[j]:\n          if t == 0:\n            break\n          t -= 1\n      ans += str(j + 1)\n      k %= fact[i]\n      visited[j] = 1\n    return ans\n", "61": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def rotateRight(self, head, k):\n    \"\"\"\n    :type head: ListNode\n    :type k: int\n    :rtype: ListNode\n    \"\"\"\n    if not head:\n      return head\n    l = 1\n    p = head\n    while p.next:\n      l += 1\n      p = p.next\n    k = k % l\n    if k == 0:\n      return head\n    k = l - k % l - 1\n    pp = head\n    print\n    k\n    while k > 0:\n      pp = pp.next\n      k -= 1\n    newHead = pp.next\n    pp.next = None\n    p.next = head\n    return newHead\n", "62": "class Solution(object):\n  def uniquePaths(self, m, n):\n    \"\"\"\n    :type m: int\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [1] * n\n\n    for i in range(1, m):\n      pre = 1\n      for j in range(1, n):\n        dp[j] = dp[j] + pre\n        pre = dp[j]\n    return dp[-1]\n", "63": "class Solution(object):\n  def uniquePathsWithObstacles(self, grid):\n    \"\"\"\n    :type obstacleGrid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not grid:\n      return 0\n    if grid[0][0] == 1:\n      return 0\n    dp = [[0] * len(grid[0]) for _ in range(0, len(grid))]\n    dp[0][0] = 1 if grid[0][0] == 0 else 0\n    for i in range(1, len(grid)):\n      if grid[i][0] == 0:\n        dp[i][0] = 1\n      else:\n        break\n\n    for j in range(1, len(grid[0])):\n      if grid[0][j] == 0:\n        dp[0][j] = 1\n      else:\n        break\n\n    for i in range(1, len(grid)):\n      for j in range(1, len(grid[0])):\n        if grid[i][j] == 1:\n          dp[i][j] = 0\n        else:\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[-1][-1]\n", "64": "class Solution(object):\n  def minPathSum(self, grid):\n    \"\"\"\n    :type grid: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if len(grid) == 0:\n      return 0\n    dp = [0 for _ in range(0, len(grid[0]))]\n    dp[0] = grid[0][0]\n\n    for j in range(1, len(grid[0])):\n      dp[j] = dp[j - 1] + grid[0][j]\n\n    for i in range(1, len(grid)):\n      pre = dp[0] + grid[i][0]\n      for j in range(1, len(grid[0])):\n        dp[j] = min(dp[j], pre) + grid[i][j]\n        pre = dp[j]\n      dp[0] += grid[i][0]\n\n    return dp[-1]\n", "65": "class States(object):\n  def __init__(self):\n    self.init = 0\n    self.decimal = 1\n    self.decpoint = 2\n    self.afterdp = 3\n    self.e = 4\n    self.aftere = 5\n    self.sign = 6\n    self.nullpoint = 7\n    self.esign = 8\n    self.afteresign = 9\n\n\nclass Solution(object):\n  def isNumber(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: bool\n    \"\"\"\n    s = s.strip()\n    states = States()\n    state = states.init\n    decimals = \"01234567890\"\n\n    for c in s:\n      if state == states.init:\n        if c == \".\":\n          state = states.nullpoint\n        elif c in decimals:\n          state = states.decimal\n        elif c in [\"+\", \"-\"]:\n          state = states.sign\n        else:\n          return False\n      elif state == states.sign:\n        if c in decimals:\n          state = states.decimal\n        elif c == \".\":\n          state = states.nullpoint\n        else:\n          return False\n      elif state == states.esign:\n        if c not in decimals:\n          return False\n        state = states.afteresign\n      elif state == states.afteresign:\n        if c not in decimals:\n          return False\n      elif state == states.nullpoint:\n        if c not in decimals:\n          return False\n        state = states.decpoint\n      elif state == states.decimal:\n        if c in decimals:\n          continue\n        elif c == \"e\":\n          state = states.e\n        elif c == \".\":\n          state = states.decpoint\n        else:\n          return False\n      elif state == states.decpoint:\n        if c in decimals:\n          state = states.afterdp\n        elif c == \"e\":\n          state = states.e\n        else:\n          return False\n      elif state == states.afterdp:\n        if c in decimals:\n          continue\n        elif c == \"e\":\n          state = states.e\n        else:\n          return False\n      elif state == states.e:\n        if c in decimals:\n          state = states.aftere\n        elif c in [\"+\", \"-\"]:\n          state = states.esign\n        else:\n          return False\n      elif state == states.aftere:\n        if c not in decimals:\n          return False\n      else:\n        return False\n    return state not in [states.init, states.e, states.nullpoint, states.sign, states.esign]\n", "66": "class Solution(object):\n  def plusOne(self, digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    carry = 1\n    for i in reversed(range(0, len(digits))):\n      digit = (digits[i] + carry) % 10\n      carry = 1 if digit < digits[i] else 0\n      digits[i] = digit\n    if carry == 1:\n      return [1] + digits\n    return digits\n", "67": "class Solution(object):\n  def addBinary(self, a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    diff = abs(len(a) - len(b))\n    if len(a) > len(b):\n      b = \"0\" * diff + b\n    else:\n      a = \"0\" * diff + a\n\n    ret = \"\"\n    carry = 0\n    ai, bi = len(a) - 1, len(b) - 1\n    al, bl = len(a), len(b)\n    while ai >= 0 and bi >= 0:\n      ac, bc = a[ai], b[bi]\n      if ac == \"1\" and bc == \"1\":\n        if carry == 1:\n          ret += \"1\"\n        else:\n          ret += \"0\"\n        carry = 1\n      elif ac == \"0\" and bc == \"0\":\n        if carry == 1:\n          ret += \"1\"\n        else:\n          ret += \"0\"\n        carry = 0\n      else:\n        if carry == 1:\n          ret += \"0\"\n        else:\n          ret += \"1\"\n\n      ai -= 1\n      bi -= 1\n\n    if carry == 1:\n      ret += \"1\"\n    return ret[::-1]\n", "68": "class Solution(object):\n  def fullJustify(self, words, maxWidth):\n    \"\"\"\n    :type words: List[str]\n    :type maxWidth: int\n    :rtype: List[str]\n    \"\"\"\n    ans = []\n    line = []\n    lens = map(len, words)\n    idx = 0\n    curLen = 0\n    while idx < len(words):\n      if curLen == 0:\n        curLen = lens[idx]\n      else:\n        curLen += lens[idx] + 1\n      line.append(words[idx])\n      idx += 1\n      if curLen > maxWidth:\n        curLen = 0\n        line.pop()\n        idx -= 1\n        if len(line) == 1:\n          ans.append(line[0] + \" \" * (maxWidth - len(line[0])))\n          line = []\n          continue\n        spaces = maxWidth - sum(map(len, line))\n        avgSpace = spaces / (len(line) - 1)\n        extraSpace = spaces % (len(line) - 1)\n        res = \"\"\n        for i in range(0, len(line)):\n          res += line[i]\n          if i < len(line) - 1:\n            res += \" \" * (avgSpace + (extraSpace > 0))\n            extraSpace -= 1\n        ans.append(res)\n        line = []\n      elif idx == len(words):\n        res = \"\"\n        for i in range(0, len(line)):\n          res += line[i]\n          if i < len(line) - 1:\n            res += \" \"\n        res += \" \" * (maxWidth - len(res))\n        ans.append(res)\n    return ans\n", "69": "class Solution(object):\n  def mySqrt(self, x):\n    \"\"\"\n    :type x: int\n    :rtype: int\n    \"\"\"\n    lo = 0\n    hi = x\n    while lo <= hi:\n      mid = (hi + lo) // 2\n      v = mid * mid\n      if v < x:\n        lo = mid + 1\n      elif v > x:\n        hi = mid - 1\n      else:\n        return mid\n    return hi\n", "70": "class Solution(object):\n  def climbStairs(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n <= 1:\n      return 1\n    pre, ppre = 1, 1\n    for i in range(2, n + 1):\n      tmp = pre\n      pre = ppre + pre\n      ppre = tmp\n    return pre\n", "71": "class Solution(object):\n  def simplifyPath(self, path):\n    \"\"\"\n    :type path: str\n    :rtype: str\n    \"\"\"\n    path = path.split(\"/\")\n    stack = []\n    for p in path:\n      if p in [\"\", \".\"]:\n        continue\n      if p == \"..\":\n        if stack:\n          stack.pop()\n      else:\n        stack.append(p)\n    return \"/\" + \"/\".join(stack)\n", "72": "class Solution(object):\n  def minDistance(self, word1, word2):\n    \"\"\"\n    :type word1: str\n    :type word2: str\n    :rtype: int\n    \"\"\"\n    if len(word1) == 0 or len(word2) == 0:\n      return max(len(word1), len(word2))\n\n    dp = [[0] * (len(word2) + 1) for _ in range(0, len(word1) + 1)]\n    dp[0][0] = 0\n\n    for i in range(0, len(word1) + 1):\n      for j in range(0, len(word2) + 1):\n        if i == 0:\n          dp[i][j] = j\n        elif j == 0:\n          dp[i][j] = i\n        else:\n          cond1 = dp[i][j - 1] + 1\n          cond2 = dp[i - 1][j] + 1\n          cond3 = 0\n          if word1[i - 1] == word2[j - 1]:\n            cond3 = dp[i - 1][j - 1]\n          else:\n            cond3 = dp[i - 1][j - 1] + 1\n          dp[i][j] = min(cond1, cond2, cond3)\n    return dp[-1][-1]\n", "73": "class Solution(object):\n  def setZeroes(self, matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: void Do not return anything, modify matrix in-place instead.\n    \"\"\"\n    colZeroFlag = False\n    for i in range(0, len(matrix)):\n      if matrix[i][0] == 0:\n        colZeroFlag = True\n      for j in range(1, len(matrix[0])):\n        if matrix[i][j] == 0:\n          matrix[i][0] = matrix[0][j] = 0\n\n    for i in reversed(range(0, len(matrix))):\n      for j in reversed(range(1, len(matrix[0]))):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n      if colZeroFlag:\n        matrix[i][0] = 0\n", "74": "class Solution(object):\n  def searchMatrix(self, matrix, target):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    if len(matrix) == 0 or len(matrix[0]) == 0:\n      return False\n\n    m = len(matrix)\n    n = len(matrix[0])\n\n    start, end = 0, m * n - 1\n    while start + 1 < end:\n      mid = start + (end - start) / 2\n      if matrix[mid / n][mid % n] > target:\n        end = mid\n      elif matrix[mid / n][mid % n] < target:\n        start = mid\n      else:\n        return True\n    if matrix[start / n][start % n] == target:\n      return True\n    if matrix[end / n][end % n] == target:\n      return True\n    return False\n", "75": "class Solution(object):\n  def sortColors(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    x = y = z = -1\n    for i in range(0, len(nums)):\n      if nums[i] == 0:\n        x += 1\n        y += 1\n        z += 1\n        if z != -1:\n          nums[z] = 2\n        if y != -1:\n          nums[y] = 1\n        nums[x] = 0\n      elif nums[i] == 1:\n        y += 1\n        z += 1\n        nums[z] = 2\n        if x != -1:\n          nums[x] = 0\n        if y != -1:\n          nums[y] = 1\n      elif nums[i] == 2:\n        z += 1\n        if y != -1:\n          nums[y] = 1\n        if x != -1:\n          nums[x] = 0\n        nums[z] = 2\n", "76": "class Solution(object):\n  def minWindow(self, s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: str\n    \"\"\"\n    score = 0\n    wanted = collections.Counter(t)\n    start, end = len(s), 3 * len(s)\n    d = {}\n    deq = collections.deque([])\n    for i, c in enumerate(s):\n      if c in wanted:\n        deq.append(i)\n        d[c] = d.get(c, 0) + 1\n        if d[c] <= wanted[c]:\n          score += 1\n        while deq and d[s[deq[0]]] > wanted[s[deq[0]]]:\n          d[s[deq.popleft()]] -= 1\n        if score == len(t) and deq[-1] - deq[0] < end - start:\n          start, end = deq[0], deq[-1]\n    return s[start:end + 1]\n", "77": "class Solution(object):\n  def combine(self, n, k):\n    if k == 1:\n      return [[i] for i in range(1, n + 1)]\n    elif k == n:\n      return [[i for i in range(1, n + 1)]]\n    else:\n      rs = []\n      rs += self.combine(n - 1, k)\n      part = self.combine(n - 1, k - 1)\n      for ls in part:\n        ls.append(n)\n      rs += part\n      return rs\n", "78": "class Solution(object):\n  def subsets(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n\n    def dfs(nums, index, path, ans):\n      ans.append(path)\n      [dfs(nums, i + 1, path + [nums[i]], ans) for i in range(index, len(nums))]\n\n    ans = []\n    dfs(nums, 0, [], ans)\n    return ans\n", "79": "class Solution:\n  # @param board, a list of lists of 1 length string\n  # @param word, a string\n  # @return a boolean\n  def exist(self, board, word):\n    # write your code here\n    if word == \"\":\n      return True\n    if len(board) == 0:\n      return False\n    visited = [[0] * len(board[0]) for i in range(0, len(board))]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def dfs(i, j, board, visited, word, index):\n      if word[index] != board[i][j]:\n        return False\n      if len(word) - 1 == index:\n        return True\n      for direction in directions:\n        ni, nj = i + direction[0], j + direction[1]\n        if ni >= 0 and ni < len(board) and nj >= 0 and nj < len(board[0]):\n          if visited[ni][nj] == 0:\n            visited[ni][nj] = 1\n            if dfs(ni, nj, board, visited, word, index + 1):\n              return True\n            visited[ni][nj] = 0\n      return False\n\n    for i in range(0, len(board)):\n      for j in range(0, len(board[0])):\n        visited[i][j] = 1\n        if dfs(i, j, board, visited, word, 0):\n          return True\n        visited[i][j] = 0\n    return False\n", "80": "class Solution(object):\n  def removeDuplicates(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 2:\n      return len(nums)\n    cnt = 0\n    j = 1\n    for i in range(1, len(nums)):\n      if nums[i] == nums[i - 1]:\n        cnt += 1\n        if cnt < 2:\n          nums[j] = nums[i]\n          j += 1\n      else:\n        nums[j] = nums[i]\n        j += 1\n        cnt = 0\n    return j\n", "81": "class Solution(object):\n  def search(self, nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: bool\n    \"\"\"\n    start, end = 0, len(nums) - 1\n    while start + 1 < end:\n      mid = start + (end - start) / 2\n      if nums[mid] == target:\n        return True\n      if nums[start] < nums[mid]:\n        if nums[start] <= target <= nums[mid]:\n          end = mid\n        else:\n          start = mid\n      elif nums[start] > nums[mid]:\n        if nums[mid] <= target <= nums[end]:\n          start = mid\n        else:\n          end = mid\n      else:\n        start += 1\n\n    if nums[start] == target:\n      return True\n    if nums[end] == target:\n      return True\n    return False\n", "82": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def deleteDuplicates(self, head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    dummy = ListNode(-1)\n    dummy.next = head\n    p = dummy\n    while p.next:\n      if p.next.next and p.next.val == p.next.next.val:\n        z = p.next\n        while z and z.next and z.val == z.next.val:\n          z = z.next\n        p.next = z.next\n      else:\n        p = p.next\n    return dummy.next\n", "83": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def deleteDuplicates(self, head):\n    \"\"\"\n    :type head: ListNode\n    :rtype: ListNode\n    \"\"\"\n    dummy = ListNode(None)\n    dummy.next = head\n    p = dummy\n\n    while p and p.next:\n      if p.val == p.next.val:\n        p.next = p.next.next\n      else:\n        p = p.next\n    return dummy.next\n", "84": "class Solution(object):\n  def largestRectangleArea(self, height):\n    \"\"\"\n    :type height: List[int]\n    :rtype: int\n    \"\"\"\n    if not height:\n      return 0\n    height.append(-1)\n    stack = []\n    ans = 0\n    for i in range(0, len(height)):\n      while stack and height[i] < height[stack[-1]]:\n        h = height[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        ans = max(ans, h * w)\n      stack.append(i)\n    height.pop()\n    return ans\n", "85": "class Solution(object):\n  def maximalRectangle(self, matrix):\n    \"\"\"\n    :type matrix: List[List[str]]\n    :rtype: int\n    \"\"\"\n\n    def histogram(height):\n      if not height:\n        return 0\n      height.append(-1)\n      stack = []\n      ans = 0\n      for i in range(0, len(height)):\n        while stack and height[i] < height[stack[-1]]:\n          h = height[stack.pop()]\n          w = i - stack[-1] - 1 if stack else i\n          ans = max(ans, h * w)\n        stack.append(i)\n      return ans\n\n    ans = 0\n    dp = [[0] * len(matrix[0]) for _ in range(0, len(matrix))]\n    for i in reversed(range(0, len(matrix))):\n      if i == len(matrix) - 1:\n        dp[i] = [int(h) for h in matrix[i]]\n      else:\n        for j in range(0, len(matrix[0])):\n          if matrix[i][j] != \"0\":\n            dp[i][j] = dp[i + 1][j] + 1\n      ans = max(ans, histogram(dp[i]))\n    return ans\n", "86": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def partition(self, head, x):\n    \"\"\"\n    :type head: ListNode\n    :type x: int\n    :rtype: ListNode\n    \"\"\"\n    if head is None:\n      return None\n    dummy = ListNode(-1)\n    dummy.next = head\n    sHead = sDummy = ListNode(-1)\n    p = dummy\n    while p and p.next:\n      if p.next.val < x:\n        sDummy.next = p.next\n        p.next = p.next.next\n        sDummy = sDummy.next\n      else:\n        p = p.next\n      # if you change p.next then make sure you wouldn't change p in next run\n    sDummy.next = dummy.next\n    return sHead.next\n", "87": "class Solution(object):\n  def isScramble(self, s1, s2):\n    \"\"\"\n    :type s1: str\n    :type s2: str\n    :rtype: bool\n    \"\"\"\n    n = len(s1)\n    m = len(s2)\n    if sorted(s1) != sorted(s2):\n      return False\n\n    if n < 4 or s1 == s2:\n      return True\n\n    for i in range(1, n):\n      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n        return True\n      if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n        return True\n    return False\n", "88": "class Solution(object):\n  def merge(self, nums1, m, nums2, n):\n    \"\"\"\n    :type nums1: List[int]\n    :type m: int\n    :type nums2: List[int]\n    :type n: int\n    :rtype: void Do not return anything, modify nums1 in-place instead.\n    \"\"\"\n    end = m + n - 1\n    m -= 1\n    n -= 1\n    while end >= 0 and m >= 0 and n >= 0:\n      if nums1[m] > nums2[n]:\n        nums1[end] = nums1[m]\n        m -= 1\n      else:\n        nums1[end] = nums2[n]\n        n -= 1\n      end -= 1\n\n    while n >= 0:\n      nums1[end] = nums2[n]\n      end -= 1\n      n -= 1\n", "89": "class Solution(object):\n  def grayCode(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: List[int]\n    \"\"\"\n    if n < 1:\n      return [0]\n    ans = [0] * (2 ** n)\n    ans[1] = 1\n    mask = 0x01\n    i = 1\n    while i < n:\n      mask <<= 1\n      for j in range(0, 2 ** i):\n        root = (2 ** i)\n        ans[root + j] = ans[root - j - 1] | mask\n      i += 1\n    return ans\n", "90": "class Solution(object):\n  def subsetsWithDup(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n\n    def dfs(start, nums, path, res, visited):\n      res.append(path + [])\n\n      for i in range(start, len(nums)):\n        if start != i and nums[i] == nums[i - 1]:\n          continue\n        if i not in visited:\n          visited[i] = 1\n          path.append(nums[i])\n          dfs(i + 1, nums, path, res, visited)\n          path.pop()\n          del visited[i]\n\n    nums.sort()\n    res = []\n    visited = {}\n    dfs(0, nums, [], res, visited)\n    return res\n", "91": "class Solution(object):\n  def numDecodings(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if len(s) == 0:\n      return 0\n    dp = [0] * (len(s) + 1)\n    dp[0] = 1\n    dp[1] = 0 if s[0] == \"0\" else 1\n    for i in range(1, len(s)):\n      pre = int(s[i - 1])\n      cur = int(s[i])\n      num = pre * 10 + cur\n      if cur != 0:\n        dp[i + 1] += dp[i]\n      if pre != 0 and 0 < num <= 26:\n        dp[i + 1] += dp[i - 1]\n\n    return dp[-1]\n", "92": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n  def reverseBetween(self, head, m, n):\n    \"\"\"\n    :type head: ListNode\n    :type m: int\n    :type n: int\n    :rtype: ListNode\n    \"\"\"\n\n    def reverse(root, prep, k):\n      cur = root\n      pre = None\n      next = None\n      while cur and k > 0:\n        next = cur.next\n        cur.next = pre\n        pre = cur\n        cur = next\n        k -= 1\n      root.next = next\n      prep.next = pre\n      return pre\n\n    dummy = ListNode(-1)\n    dummy.next = head\n    k = 1\n    p = dummy\n    start = None\n    while p:\n      if k == m:\n        start = p\n      if k == n + 1:\n        reverse(start.next, start, n - m + 1)\n        return dummy.next\n      k += 1\n      p = p.next\n", "93": "class Solution(object):\n  def restoreIpAddresses(self, s):\n    \"\"\"\n    :type s: str\n    :rtype: List[str]\n    \"\"\"\n    ans = []\n    n = len(s)\n\n    def isValid(num):\n      if len(num) == 1:\n        return True\n      if len(num) > 1 and num[0] != \"0\" and int(num) <= 255:\n        return True\n      return False\n\n    for i in range(0, min(3, n - 3)):\n      a = s[:i + 1]\n      if not isValid(a):\n        break\n      for j in range(i + 1, min(i + 4, n - 2)):\n        b = s[i + 1:j + 1]\n        if not isValid(b):\n          break\n        for k in range(j + 1, min(j + 4, n - 1)):\n          c = s[j + 1:k + 1]\n          d = s[k + 1:]\n          if not isValid(c):\n            break\n          if not isValid(d):\n            continue\n          ans.append(\"{}.{}.{}.{}\".format(a, b, c, d))\n    return ans\n", "94": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n  def inorderTraversal(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: List[int]\n    \"\"\"\n    res, stack = [], [(1, root)]\n    while stack:\n      p = stack.pop()\n      if not p[1]: continue\n      stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val)\n    return res\n", "95": "class Solution(object):\n  def generateTrees(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: List[TreeNode]\n    \"\"\"\n\n    def clone(root, offset):\n      if root:\n        newRoot = TreeNode(root.val + offset)\n        left = clone(root.left, offset)\n        right = clone(root.right, offset)\n        newRoot.left = left\n        newRoot.right = right\n        return newRoot\n\n    if not n:\n      return []\n    dp = [[]] * (n + 1)\n    dp[0] = [None]\n    for i in range(1, n + 1):\n      dp[i] = []\n      for j in range(1, i + 1):\n        for left in dp[j - 1]:\n          for right in dp[i - j]:\n            root = TreeNode(j)\n            root.left = left\n            root.right = clone(right, j)\n            dp[i].append(root)\n    return dp[-1]\n", "96": "class Solution(object):\n  def _numTrees(self, n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n      for j in range(1, i + 1):\n        dp[i] += dp[j - 1] * dp[i - j]\n    return dp[-1]\n\n  def numTrees(self, n):\n    ans = 1\n    for i in range(1, n + 1):\n      ans = ans * (n + i) / i\n    return ans / (n + 1)\n", "97": "class Solution(object):\n  def isInterleave(self, s1, s2, s3):\n    \"\"\"\n    :type s1: str\n    :type s2: str\n    :type s3: str\n    :rtype: bool\n    \"\"\"\n    d = {}\n    s3 = list(s3)\n    if len(s1) + len(s2) != len(s3):\n      return False\n\n    def dfs(s1, i, s2, j, d, path, s3):\n      if (i, j) in d:\n        return d[(i, j)]\n\n      if path == s3:\n        return True\n\n      if i < len(s1):\n        if s3[i + j] == s1[i]:\n          path.append(s1[i])\n          if dfs(s1, i + 1, s2, j, d, path, s3):\n            return True\n          path.pop()\n          d[(i + 1, j)] = False\n\n      if j < len(s2):\n        if s3[i + j] == s2[j]:\n          path.append(s2[j])\n          if dfs(s1, i, s2, j + 1, d, path, s3):\n            return True\n          path.pop()\n          d[(i, j + 1)] = False\n\n      return False\n\n    return dfs(s1, 0, s2, 0, d, [], s3)\n", "98": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n  def isValidBST(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: bool\n    \"\"\"\n    prev = -float(\"inf\")\n    stack = [(1, root)]\n    while stack:\n      p = stack.pop()\n      if not p[1]:\n        continue\n      if p[0] == 0:\n        if p[1].val <= prev:\n          return False\n        prev = p[1].val\n      else:\n        stack.append((1, p[1].right))\n        stack.append((0, p[1]))\n        stack.append((1, p[1].left))\n    return True\n", "99": "class Solution:\n  def __init__(self):\n    self.n1 = None\n    self.n2 = None\n    self.pre = None\n\n  def findBadNode(self, root):\n    if root is None: return\n    self.findBadNode(root.left)\n    if self.pre is not None:\n      if root.val < self.pre.val:\n        if self.n1 is None:\n          self.n1 = self.pre\n          self.n2 = root\n        else:\n          self.n2 = root\n    self.pre = root\n    self.findBadNode(root.right)\n\n  def recoverTree(self, root):\n    self.findBadNode(root)\n    if self.n1 is not None and self.n2 is not None:\n      self.n1.val, self.n2.val = self.n2.val, self.n1.val\n"}